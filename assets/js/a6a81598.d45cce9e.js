"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[77876],{25484:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var r=i(74848),s=i(28453);const t={sidebar_position:3},o="Part 2: Physics Foundation",l={id:"tutorials/platformer-tutorial/part-2-physics",title:"Part 2: Physics Foundation",description:"In this part, we'll implement Box2D physics in our platformer game, creating the foundation for realistic movement and collision detection.",source:"@site/docs/tutorials/platformer-tutorial/part-2-physics.md",sourceDirName:"tutorials/platformer-tutorial",slug:"/tutorials/platformer-tutorial/part-2-physics",permalink:"/docs/tutorials/platformer-tutorial/part-2-physics",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorials",previous:{title:"Part 1: Project Setup and Assets",permalink:"/docs/tutorials/platformer-tutorial/part-1-setup"},next:{title:"Part 3: Player Character",permalink:"/docs/tutorials/platformer-tutorial/part-3-player"}},a={},c=[{value:"What We&#39;ll Accomplish",id:"what-well-accomplish",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Understanding Box2D Integration",id:"step-1-understanding-box2d-integration",level:2},{value:"Step 2: Create Physics Helper Class",id:"step-2-create-physics-helper-class",level:2},{value:"Step 3: Update GameLayer with Physics",id:"step-3-update-gamelayer-with-physics",level:2},{value:"Step 4: Understanding Physics Concepts",id:"step-4-understanding-physics-concepts",level:2},{value:"Key Physics Concepts:",id:"key-physics-concepts",level:3},{value:"Important Settings:",id:"important-settings",level:3},{value:"Step 5: Build and Test",id:"step-5-build-and-test",level:2},{value:"Step 6: Adding Debug Rendering (Optional)",id:"step-6-adding-debug-rendering-optional",level:2},{value:"Checkpoint: What Your Project Should Look Like",id:"checkpoint-what-your-project-should-look-like",level:2},{value:"New Files:",id:"new-files",level:3},{value:"What You Should See:",id:"what-you-should-see",level:3},{value:"Key Concepts Learned:",id:"key-concepts-learned",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Understanding Performance",id:"understanding-performance",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Download Checkpoint Project",id:"download-checkpoint-project",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.RP)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"part-2-physics-foundation",children:"Part 2: Physics Foundation"}),"\n",(0,r.jsx)(n.p,{children:"In this part, we'll implement Box2D physics in our platformer game, creating the foundation for realistic movement and collision detection."}),"\n",(0,r.jsx)(n.h2,{id:"what-well-accomplish",children:"What We'll Accomplish"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this part, you'll have:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A working Box2D physics world with gravity"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of physics coordinate systems"}),"\n",(0,r.jsx)(n.li,{children:"Helper utilities for physics conversions"}),"\n",(0,r.jsx)(n.li,{children:"A basic physics debug renderer"}),"\n",(0,r.jsx)(n.li,{children:"Foundation for character and platform physics"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Completed ",(0,r.jsx)(n.a,{href:"./part-1-setup",children:"Part 1: Project Setup and Assets"})]}),"\n",(0,r.jsx)(n.li,{children:"Understanding of basic physics concepts (gravity, velocity, forces)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-1-understanding-box2d-integration",children:"Step 1: Understanding Box2D Integration"}),"\n",(0,r.jsx)(n.p,{children:"cocos2d-mono comes with Box2D physics built-in. Box2D uses a different coordinate system and units than cocos2d:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Box2D units"}),": Meters (optimal for objects 0.1 to 10 meters)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cocos2d units"}),": Pixels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coordinate system"}),": Box2D uses bottom-left origin, cocos2d uses variable origin"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We need conversion utilities to bridge these differences."}),"\n",(0,r.jsx)(n.h2,{id:"step-2-create-physics-helper-class",children:"Step 2: Create Physics Helper Class"}),"\n",(0,r.jsxs)(n.p,{children:["Create a new file called ",(0,r.jsx)(n.code,{children:"PhysicsHelper.cs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using Cocos2D;\r\nusing Box2D.Dynamics;\r\nusing Box2D.Collision.Shapes;\r\nusing Box2D.Common;\r\n\r\nnamespace Platformer\r\n{\r\n    public static class PhysicsHelper\r\n    {\r\n        // Physics constants\r\n        public const float PTM_RATIO = 32.0f; // Pixels to meters ratio\r\n\r\n        // Categories for collision filtering\r\n        public const ushort CATEGORY_PLAYER = 0x0001;\r\n        public const ushort CATEGORY_PLATFORM = 0x0002;\r\n        public const ushort CATEGORY_COLLECTIBLE = 0x0004;\r\n\r\n        // Convert from cocos2d coordinates to Box2D coordinates\r\n        public static b2Vec2 ToPhysicsVector(CCPoint point)\r\n        {\r\n            return new b2Vec2(point.X / PTM_RATIO, point.Y / PTM_RATIO);\r\n        }\r\n\r\n        // Convert from Box2D coordinates to cocos2d coordinates\r\n        public static CCPoint ToCocosVector(b2Vec2 vector)\r\n        {\r\n            return new CCPoint(vector.x * PTM_RATIO, vector.y * PTM_RATIO);\r\n        }\r\n        \r\n        // Create a rectangular physics body\r\n        public static b2Body CreateBoxBody(b2World world, float x, float y, float width, float height,\r\n            bool isDynamic = false, float density = 1.0f, float friction = 0.3f, float restitution = 0.1f)\r\n        {\r\n            // Define body\r\n            b2BodyDef bodyDef = new b2BodyDef();\r\n            bodyDef.position = new b2Vec2(x / PTM_RATIO, y / PTM_RATIO);\r\n            bodyDef.type = isDynamic ? b2BodyType.b2_dynamicBody : b2BodyType.b2_staticBody;\r\n\r\n            // Create body\r\n            b2Body body = world.CreateBody(bodyDef);\r\n\r\n            // Define fixture\r\n            b2PolygonShape shape = new b2PolygonShape();\r\n            shape.SetAsBox(width / (2 * PTM_RATIO), height / (2 * PTM_RATIO));\r\n            \r\n            b2FixtureDef fixtureDef = new b2FixtureDef();\r\n            fixtureDef.shape = shape;\r\n            fixtureDef.density = density;\r\n            fixtureDef.friction = friction;\r\n            fixtureDef.restitution = restitution;\r\n\r\n            // Add fixture to body\r\n            body.CreateFixture(fixtureDef);\r\n\r\n            return body;\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-3-update-gamelayer-with-physics",children:"Step 3: Update GameLayer with Physics"}),"\n",(0,r.jsxs)(n.p,{children:["Now let's update our ",(0,r.jsx)(n.code,{children:"GameLayer.cs"})," to include Box2D physics:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using Cocos2D;\r\nusing Box2D.Dynamics;\r\nusing System;\r\n\r\nnamespace Platformer\r\n{\r\n    public class GameLayer : CCLayer\r\n    {\r\n        // Physics world\r\n        private b2World physicsWorld;\r\n        private b2Body groundBody;\r\n        \r\n        // Physics settings\r\n        private const int VELOCITY_ITERATIONS = 8;\r\n        private const int POSITION_ITERATIONS = 3;\r\n        private const float TIME_STEP = 1.0f / 60.0f;\r\n        \r\n        public GameLayer()\r\n        {\r\n            // Get visible area size\r\n            CCSize visibleSize = CCDirector.SharedDirector.WinSize;\r\n            \r\n            // Initialize physics world\r\n            InitializePhysics(visibleSize);\r\n            \r\n            // Create background\r\n            CCSprite background = new CCSprite("background");\r\n            background.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height / 2);\r\n            \r\n            // Scale background to fit screen\r\n            float scaleX = visibleSize.Width / background.ContentSize.Width;\r\n            float scaleY = visibleSize.Height / background.ContentSize.Height;\r\n            background.Scale = Math.Max(scaleX, scaleY);\r\n            \r\n            AddChild(background, -1);\r\n            \r\n            // Create some test physics objects\r\n            CreateTestObjects(visibleSize);\r\n            \r\n            // Add labels for information\r\n            CCLabelTTF titleLabel = new CCLabelTTF("Platformer Tutorial - Part 2: Physics", "Arial", 24);\r\n            titleLabel.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height - 30);\r\n            titleLabel.Color = CCColor3B.White;\r\n            AddChild(titleLabel);\r\n            \r\n            CCLabelTTF infoLabel = new CCLabelTTF("Physics World Active - Objects will fall!", "Arial", 16);\r\n            infoLabel.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height - 60);\r\n            infoLabel.Color = CCColor3B.Yellow;\r\n            AddChild(infoLabel);\r\n            \r\n            // Enable updates to step the physics world\r\n            ScheduleUpdate();\r\n        }\r\n        \r\n        private void InitializePhysics(CCSize worldSize)\r\n        {\r\n            // Create physics world\r\n            physicsWorld = PhysicsHelper.CreateWorld();\r\n            \r\n            // Create world boundaries\r\n            groundBody = PhysicsHelper.CreateWorldBoundaries(physicsWorld, worldSize);\r\n            \r\n            // Set up contact listener for collision detection (we\'ll expand this later)\r\n            // physicsWorld.SetContactListener(new ContactListener());\r\n        }\r\n        \r\n        private void CreateTestObjects(CCSize visibleSize)\r\n        {\r\n            // Create some test boxes to demonstrate physics\r\n            for (int i = 0; i < 3; i++)\r\n            {\r\n                // Create a visual sprite\r\n                CCSprite testBox = new CCSprite("platform"); // Using platform texture as test\r\n                testBox.Position = new CCPoint(200 + i * 100, 400 + i * 50);\r\n                testBox.Color = new CCColor3B((byte)(100 + i * 50), (byte)(150 - i * 30), (byte)(200));\r\n                AddChild(testBox, 1);\r\n                \r\n                // Create corresponding physics body\r\n                b2Body physicsBody = PhysicsHelper.CreateDynamicBody(\r\n                    physicsWorld, \r\n                    testBox.Position, \r\n                    testBox.ContentSize,\r\n                    1.0f\r\n                );\r\n                \r\n                // Store reference to sprite in physics body user data\r\n                physicsBody.UserData = testBox;\r\n            }\r\n            \r\n            // Create a static platform to catch falling objects\r\n            CCSprite platform = new CCSprite("platform");\r\n            platform.Position = new CCPoint(visibleSize.Width / 2, 150);\r\n            platform.ScaleX = 4.0f; // Make it wider\r\n            AddChild(platform, 1);\r\n            \r\n            // Create static physics body for platform\r\n            b2Body platformBody = PhysicsHelper.CreateStaticBody(\r\n                physicsWorld,\r\n                platform.Position,\r\n                new CCSize(platform.ContentSize.Width * platform.ScaleX, platform.ContentSize.Height)\r\n            );\r\n            platformBody.UserData = platform;\r\n        }\r\n        \r\n        public override void Update(float dt)\r\n        {\r\n            base.Update(dt);\r\n            \r\n            // Step the physics world\r\n            physicsWorld.Step(TIME_STEP, VELOCITY_ITERATIONS, POSITION_ITERATIONS);\r\n            \r\n            // Update visual positions based on physics bodies\r\n            UpdateVisualPositions();\r\n        }\r\n        \r\n        private void UpdateVisualPositions()\r\n        {\r\n            // Iterate through all physics bodies and update their corresponding sprites\r\n            for (b2Body body = physicsWorld.BodyList; body != null; body = body.Next)\r\n            {\r\n                if (body.UserData is CCSprite sprite)\r\n                {\r\n                    // Convert physics position back to cocos2d coordinates\r\n                    CCPoint newPosition = PhysicsHelper.VectorToPoint(body.Position);\r\n                    sprite.Position = newPosition;\r\n                    \r\n                    // Update rotation if needed\r\n                    sprite.Rotation = -CCMathHelper.ToDegrees(body.Angle);\r\n                }\r\n            }\r\n        }\r\n        \r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing)\r\n            {\r\n                // Clean up physics world\r\n                physicsWorld?.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"step-4-understanding-physics-concepts",children:"Step 4: Understanding Physics Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"key-physics-concepts",children:"Key Physics Concepts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"World"}),": The physics simulation container"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bodies"}),": Objects that can move and collide"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static"}),": Never moves (platforms, walls)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic"}),": Affected by forces (player, enemies)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kinematic"}),": Moves but not affected by forces (moving platforms)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fixtures"}),": Attach shapes to bodies and define material properties"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shapes"}),": Define collision geometry (box, circle, polygon)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"important-settings",children:"Important Settings:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Density"}),": Mass per unit area (affects how heavy objects feel)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Friction"}),": Resistance to sliding (0 = ice, 1 = rough surface)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Restitution"}),": Bounciness (0 = no bounce, 1 = perfectly elastic)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-5-build-and-test",children:"Step 5: Build and Test"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Build the project (F6)"}),"\n",(0,r.jsx)(n.li,{children:"Run the game (F5)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You should see:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your background"}),"\n",(0,r.jsx)(n.li,{children:"Several colored boxes falling due to gravity"}),"\n",(0,r.jsx)(n.li,{children:"Boxes landing on a platform and coming to rest"}),"\n",(0,r.jsx)(n.li,{children:'Title showing "Part 2: Physics"'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-6-adding-debug-rendering-optional",children:"Step 6: Adding Debug Rendering (Optional)"}),"\n",(0,r.jsx)(n.p,{children:"For development, it's helpful to see physics shapes. Add this to your GameLayer:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Add to the top of GameLayer.cs\r\nusing Box2D.Dynamics;\r\n\r\n// Add these fields to GameLayer class\r\nprivate bool showPhysicsDebug = true;\r\n\r\n// Add this method to GameLayer\r\nprivate void DrawPhysicsDebug()\r\n{\r\n    if (!showPhysicsDebug) return;\r\n    \r\n    // Simple debug drawing - draw rectangles for physics bodies\r\n    for (b2Body body = physicsWorld.BodyList; body != null; body = body.Next)\r\n    {\r\n        if (body.UserData is CCSprite sprite)\r\n        {\r\n            // Draw a simple outline around physics bodies\r\n            CCPoint position = PhysicsHelper.VectorToPoint(body.Position);\r\n            \r\n            // This is a simplified debug visualization\r\n            // In a full implementation, you'd want proper debug drawing\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"checkpoint-what-your-project-should-look-like",children:"Checkpoint: What Your Project Should Look Like"}),"\n",(0,r.jsx)(n.p,{children:"At this point, your project should have:"}),"\n",(0,r.jsx)(n.h3,{id:"new-files",children:"New Files:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PhysicsHelper.cs"})," - Physics utility functions"]}),"\n",(0,r.jsxs)(n.li,{children:["Updated ",(0,r.jsx)(n.code,{children:"GameLayer.cs"})," - Physics integration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"what-you-should-see",children:"What You Should See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Boxes falling from the top of the screen"}),"\n",(0,r.jsx)(n.li,{children:"Objects landing on a platform and stopping"}),"\n",(0,r.jsx)(n.li,{children:"Realistic physics behavior with gravity"}),"\n",(0,r.jsx)(n.li,{children:"Smooth 60 FPS with physics simulation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts-learned",children:"Key Concepts Learned:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Box2D coordinate system and unit conversion"}),"\n",(0,r.jsx)(n.li,{children:"Creating physics worlds and bodies"}),"\n",(0,r.jsx)(n.li,{children:"Static vs dynamic physics bodies"}),"\n",(0,r.jsx)(n.li,{children:"Physics simulation loop"}),"\n",(0,r.jsx)(n.li,{children:"Synchronizing visual sprites with physics bodies"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.p,{children:"Common issues and solutions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Objects falling through platforms"}),": Check that static bodies are created correctly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Objects moving too fast"}),": Adjust TIME_STEP or increase iteration counts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Jittery movement"}),": Ensure consistent frame rate and proper conversion ratios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory issues"}),": Make sure to dispose of physics world properly"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-performance",children:"Understanding Performance"}),"\n",(0,r.jsx)(n.p,{children:"Physics simulation can be expensive. Key performance tips:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use appropriate iteration counts (8 velocity, 3 position is usually good)"}),"\n",(0,r.jsx)(n.li,{children:"Don't create too many dynamic bodies"}),"\n",(0,r.jsx)(n.li,{children:"Use static bodies for non-moving objects"}),"\n",(0,r.jsx)(n.li,{children:"Consider sleeping inactive bodies"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.p,{children:["Great work! You now have a solid physics foundation. In ",(0,r.jsx)(n.a,{href:"./part-3-player",children:"Part 3: Player Character"}),", we'll create a controllable player character that uses physics for movement and can interact with the world."]}),"\n",(0,r.jsx)(n.p,{children:"Key topics in Part 3:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creating a player character class"}),"\n",(0,r.jsx)(n.li,{children:"Implementing keyboard/gamepad input"}),"\n",(0,r.jsx)(n.li,{children:"Physics-based movement and jumping"}),"\n",(0,r.jsx)(n.li,{children:"Character animations"}),"\n",(0,r.jsx)(n.li,{children:"Basic state management"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"download-checkpoint-project",children:"Download Checkpoint Project"}),"\n",(0,r.jsxs)(n.p,{children:["You can download the complete Part 2 project ",(0,r.jsx)(n.a,{href:"https://github.com/brandmooffin/cocos2d-mono-samples/tree/main/Tutorial%20Samples/Platformer/Checkpoints/Part%202",children:"here"})," to compare with your implementation."]})]})}function h(e={}){const{wrapper:n}={...(0,s.RP)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{RP:()=>t});var r=i(96540);const s=r.createContext({});function t(e){const n=r.useContext(s);return r.useMemo(()=>"function"==typeof e?e(n):{...n,...e},[n,e])}}}]);